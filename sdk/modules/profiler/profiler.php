<?php
/**
 * Profiler Class
 *
 *     $profiler = SDK::instance('profiler');
 * 	   $benchmark = $profiler->start('APP', __FUNCTION__);
 *     $profiler->stop($benchmark);
 *     $profiler->show();
 *
 * @author lizhong <lizhong@ifeng.com>
 * @version 0.1
 */

class Profiler extends SDK_Base
{
	/**
	 * @var array
	 * save all marks into this
	 */
	protected $_marks = array();

	/**
	 * @var object
	 * how the profiler should be displayed
	 */
	protected $_adapter;

	protected function _afterConstruct($id)
	{
		$adapter = $id;
		if (empty($adapter))
		{
			$adapter = $this->_config['adapter'];
		}
		$this->_adapter = SDK::instance($adapter);
		if (!$this->_adapter instanceof Profiler_Adapter)
		{
			throw new Profiler_Exception('adapter "{adapter}" should extend Profiler_Adapter class',
			   	array('{adapter}' => $adapter));
		}
	}

	/**
	 * start profiler
	 *
	 * all benchmark with same group will group in one talbe when render to html
	 *
	 * @param string $group the group benchmark name
	 * @param string $name the benchmark name
	 * @return string the token generated by profiler
	 */
	public function start($group, $name)
	{
		static $counter = 0;
		$token = 'kp/'.base_convert($counter++, 10, 32);

		$this->$_marks[$token] = array (
			'group' => strtolower($group),
			'name'  => (string) $name,
			'start_time'   => microtime(true),
			'start_memory' => memory_get_usage(),
			'stop_time'    => false,
			'stop_memory'  => false,
		);

		return $token;
	}

	/**
	 * stop profiler by certain token
	 *
	 * @param string $token token generated by $this->start 
	 */
	public function stop($token)
	{
		$this->$_marks[$token]['stop_time']   = microtime(true);
		$this->$_marks[$token]['stop_memory'] = memory_get_usage();
	}

	/**
	 * delete token
	 *
	 * usually when you don't need this benchmark anymore
	 *
	 * @param string $token
	 */
	public function delete($token)
	{
		unset($this->$_marks[$token]);
	}

	/**
	 * reorder $_marks into groups for render convinence
	 *
	 * @return array the ordered groups
	 */
	public function groups()
	{
		$groups = array();
		foreach ($this->_marks as $token => $mark)
		{
			$groups[$mark['group']][$mark['name']][] = $token;
		}
		return $groups;
	}

	/**
	 * the stats of tokens
	 *
	 * @param array $tokens
	 * @return array the stats with certain segments
	 */
	public function stats(array $tokens)
	{
		$min = $max = array(
			'time' => null,
			'memory' => null
			);

		$total = array(
			'time' => 0,
			'memory' => 0
			);

		foreach ($tokens as $token)
		{
			list($time, $memory) = $this->total($token);

			if ($max['time'] === null || $time > $max['time'])
			{
				$max['time'] = $time;
			}

			if ($min['time'] === null || $time < $min['time'])
			{
				$min['time'] = $time;
			}

			$total['time'] += $time;

			if ($max['memory'] === null || $memory > $max['memory'])
			{
				$max['memory'] = $memory;
			}

			if ($min['memory'] === null || $memory < $min['memory'])
			{
				$min['memory'] = $memory;
			}

			$total['memory'] += $memory;
		}

		$count = count($tokens);
		$average = array(
			'time' => $total['time'] / $count,
			'memory' => $total['memory'] / $count
			);

		return array(
			'min' => $min,
			'max' => $max,
			'total' => $total,
			'average' => $average
		);
	}

	/**
	 * used for html render
	 *
	 * @param mixed $groups which groups to state
	 * @return array groups
	 */
	public function groupStats($groups = null)
	{
		$groups = ($groups === null)
			? $this->groups()
			: array_intersect_key($this->groups(), array_flip((array) $groups));

		$stats = array();

		foreach ($groups as $group => $names)
		{
			foreach ($names as $name => $tokens)
			{
				$_stats = $this->stats($tokens);
				$stats[$group][$name] = $_stats['total'];
			}
		}

		$groups = array();

		foreach ($stats as $group => $names)
		{
			$groups[$group]['min'] = $groups[$group]['max'] = array(
				'time' => null,
				'memory' => null
				);

			$groups[$group]['total'] = array(
				'time' => 0,
				'memory' => 0
				);

			foreach ($names as $total)
			{
				if (!isset($groups[$group]['min']['time']) || $groups[$group]['min']['time'] > $total['time'])
				{
					$groups[$group]['min']['time'] = $total['time'];
				}
				if (!isset($groups[$group]['min']['memory']) || $groups[$group]['min']['memory'] > $total['memory'])
				{
					$groups[$group]['min']['memory'] = $total['memory'];
				}
				if (!isset($groups[$group]['max']['time']) || $groups[$group]['max']['time'] < $total['time'])
				{
					$groups[$group]['max']['time'] = $total['time'];
				}
				if (!isset($groups[$group]['max']['memory']) || $groups[$group]['max']['memory'] < $total['memory'])
				{
					$groups[$group]['max']['memory'] = $total['memory'];
				}

				$groups[$group]['total']['time'] += $total['time'];
				$groups[$group]['total']['memory'] += $total['memory'];
			}

			$count = count($names);
			$groups[$group]['average']['time'] = $groups[$group]['total']['time'] / $count;
			$groups[$group]['average']['memory'] = $groups[$group]['total']['memory'] / $count;
		}

		return $groups;
	}

	/**
	 * the total time / memory of certain token
	 *
	 * @param string $token
	 * @return array 
	 */
	public function total($token)
	{
		$mark = $this->$_marks[$token];

		if ($mark['stop_time'] === false)
		{
			$mark['stop_time'] = microtime(true);
			$mark['stop_memory'] = memory_get_usage();
		}

		return array(
			$mark['stop_time'] - $mark['start_time'],
			$mark['stop_memory'] - $mark['start_memory'],
		);
	}

	/**
	 * application's start time / memory usage
	 *
	 * @return array
	 */
	public function application()
	{
		if (!defined('APP_START_TIME'))
		{
			$time = 'please define APP_START_TIME at start. APP_START_TIME = microtime(true)';
		} 
		else
		{
			$time = microtime(true) - APP_START_TIME;
		}

		if (!defined('APP_START_MEMORY'))
		{
			$memory = 'please define APP_START_MEMORY at start. APP_START_MEMORY = memory_get_usage()';
		}
		else
		{
			$memory = memory_get_usage() - APP_START_MEMORY;
		}

		return array('time' => $time, 'memory' => $memory);
	}

	/**
	 * display profiler result
	 */
	public function show()
	{
		if (!$this->_config['enabled'])
			return;

		static $registed = false;
		if (!$registed)
		{
			register_shutdown_function(array($this->_adapter, 'render'), $this);
			$registed = true;
		}
	}

}
